FRP (functional reactive programming) на Bacon.js

Часто, при создании достаточно сложных приложений на JavaScript наступает тот момент, когда становиться совершенно непонятно почему приложение перестало работать как надо, или наоборот вдруг заработало. Понятно, что связей между элементами приложения так, много, что уследить за ними даже с хорошими средствами деббагинга очень трудно. И вот диллема: с одной стороны есть известная методика создания приложений на JS, столь привычная и глубоко описанная, что недостатков мы уже как бы и не замечаем. С другой стороны есть масса библиотек предлагающих нам <s>перейти на другую сторону</s> попробовать что-то новое. К таким библиотекам относиться и <a href="https://github.com/baconjs/bacon.js">Bacon.js,</a> предоставляя реализацию FRP на JavaScript.  

<habracut />

<b>Пару слов о FRP и его прикладном смысле.</b>
Если не вдаваться в дао функционального программирования, то можно выделить несколько моментов FRP особо притягательных для веб-разработки. Это:
	*явные состояния, 
	*распространение изменений, 
	*работа не данными, а с источниками данных. 
С состояниями, конечно, не все так прозрачно. Все FRP реализации для JavaScript, что логично, написаны на самом JS или компилируются в него. Так что где-то под капотом браузера все равно происходит все то же самое, что и происходило бы в коде без bacon.js, но вся мякотка в том, что больше это не наша забота. Задача разработчика сводиться к тому, чтобы думать над логикой приложения.

FRP подразумевает, что источники данных - это некие свойства, изменение которых влечет за собой немедленное изменение всех прочих данных, которые зависят от них. По итогу получается структурное дерево описывающее зависимость одних данных от других, что делает систему прозрачной и легкоусвояемой. Внешне все очень вкусно, однако есть свои минусы, но об этом в конце статьи. 

Сейчас бы хотелось перейти к прикладной части, а именно на примере продемонстрировать преимущества FRP в целом и Bacon.js в частности перед императивным программированием. В качестве примера возьму хорошо известную игру <a href="http://en.wikipedia.org/wiki/Sokoban">Sokoban</a>, которую я реализую с применением Bacon.js и просто с помощью голого jQuery, чтобы наглядно различия.

Чтобы не вдаваться в лишнюю детализацию, можно посмотреть сразу на <a href="http://codepen.io/zefirka/pen/seFwj">результат</a>. В контексте этой статьи рассматривать объектную модель, реализацию алгоритма игры, и тем более внешний вид не имеет смысла. Я бы хотел сконцентрировать ваше внимание на функциональной части игры, на механизме, который всем управляет. Если у кого-то возникнет непреодолимое желание ознакомиться с сырцами, то <a href="https://github.com/zefirka/FRPSocoban">прошу</a>. Но в двух словах все работает так: мы задаем ширину и высоту игрового поля (DHTML), рисуем уровень (JSON объект) и с помощью стрелок двигаем игрока (блок с зеленым фоном) по полю, пытаясь переместить желтые ячейки на синие, когда все желтые ячейки находятся на синих - уровень пройден. 

<b>Практическое применение</b>
А теперь к самому главному. Как обычно мы реализуем реагирование на действия пользователя? Вешаем хендлеры!

<source lang="javascript">
$(document).on("keydown", function(e){
	//вот здесь происходит механика игры
});
</source>

Игра управляется 4-мя клавишами. И тут же сразу возникает проблема условной проверки, что синтаксически выглядит так.

<source lang="javascript">
if(e.keyCode >= 37 && e.keyCode <= 40){
     //механика игры на самом деле здесь
}
</source>

Мы ничего толком не успели начать, а уже приходится работать в рамках этого самого условия. Например для вычисления направления движения. По мере продвижения вглубь логической структуры игры мы сталкиваемся с многочисленными проверками окружающей среды, единственной целью которых служит определение текущего неявного состояния.
Что же предлагает bacon.js? В bacon.js определены потоки (EventStream) и свойства (Property), - состояния потоков в определенное время. Потоки можно обрабатывать, соединять, комбинировать. Здесь есть наглядные диаграммы методов. Таким образом описание нужных реакций сводится к описанию порядка событий в потоке и преобразованию данных потока. Идея в том, чтобы не следить за одиночными событиями и обрабатывать каждое из них в отдельности, а заполучить источник данных, то есть поток событий из которого можно извлекать только нужные. Например с применением фильтров:

<source lang="javascript">
var keyDowns = $(document).asEventStream("keydown"); //поток событий keydown на $(document)
var arrowDowns = keyDowns.filter(isArrows); //поток событий, таких, что прошли фильтр isArrows

function isArrows(e){
	//здесь asEventStream передает в эту функцию jQuery.Event 
   return e.keyCode >= 37 && e.keyCode <= 40
}
</source>

Или с применением map'ов:

<source lang="javascript">
var changeDirection =  $(document).asEventStream("keydown")
				.filter(isArrows) 		//если метод filter возвращает true, то передаем эвент дальше, в противном случае не слушаем
				.map(selectDirection)	//map возвращает значение selectDirection(event)
				.onValue(function(x){  //и выполним анонимную функцию, для этих событий
      that.direction.x = x.x;
      that.direction.y = x.y;
});

function selectDirection(e){
      return { 
            x : e.keyCode % 2 ? e.keyCode - 38 : 0, 
            y : !(e.keyCode % 2) ? e.keyCode - 39 : 0 
      }
}
</source>

Или как-нибудь еще. Методов для работы с потоками и свойствами много. Суть даже не в том какой функционал предоставляет Bacon.js, а в том, что потом можно делать с этими потоками событий. Если общий алгоритм игры без bacon.js представляет собой хитросплетенный лабиринт условий и состояний, то с помощью FRP мы достигаем вполне себе декларативного описания состояний программы и источников данных.
Мы привыкли изменять состояния системы, когда происходят нужные события, будь то ввод с клавиатуры или клик по какому-нибудь объекту. Чтобы понять, что события нужные приходится вешать хендлеры и пристально следить за развитием событий. Приходится много планировать и предугадывать как вообще поведет себя юзер, чтобы на всякое состояние были свои действия. Но в действительности меня как разработчика мало интересует чего такого сделал юзер, если это логически не влияет на состояние системы. В таком подходе декларативное описание событий очень сильно облегчает жизнь так как не требует проверок в стиле "а правда, что юзер ткнул именно эту кнопку на клавиатуре, а не какую-то другую". 

<source lang="javascript">	
var playerMove = $(document).asEventStream("keydown") //события keydown на $(document)
									.filter(isArrows)				//которые являются нажатиями на стрелки
									.map(player) 					//для игрока
									.map(nextCell); 				//ячейка, куда направленно его движение.  

//поток событий, таких, что следующая ячейка куда двигается игрок пуста
var playerNextEmpty =  playerMove.filter(isEmpty).onValue(function(nov){
	//меняем координаты игрока.
});

//поток событий, таких, что следующая ячейка куда двигается игрок - подвижный блок
var goalMove = playerMove.map(isGoal).filter(function(x){return x});

//поток событий, таких, что следующая ячейка за той, где стоит подвижный блок - пуста
var goalNextEmpty = goalMove.map(nextCell).filter(isEmpty).onValue(function(x){
	//меняем координаты блока
});
</source>

Как видно, синтаксис сам подталкиевает к тому, чтобы писать очевидно. На самом деле все можно сделать еще проще, если использовать методы scan() и combine(), но я хотел показать самые простые методы map() и filter(). Такой подход упрощает задачу, когда нужно дополнять систему новыми элементами с новым функционалом. Например добавить на поле мины. Если игрок окажется на мине или толкнет не него блок, то игра будет считаться проигранной.

<source lang="javascript">	
//поток событий, таких, что следующая ячейка, куда двигается игрок - мина
var playerNextMine = playerMove.filter(isMine); 
//поток событий, таких, что следующая ячейка, куда будет перемещен блок - мина
var goalNextMine = goalMove.map(nextCell).filter(isMine);
//совмещенный поток событий playerNextMine и goalNextMine.
var mineAlert = goalNextMine.merge(playerNextMine).onValue(function(x){
	//игра проигранна
});
</source>

Добавить точно такой-же функционал в императивном стиле было бы намного сложнее т.к. в запутанную систему из условных проверок и идентификации состояний нужно было бы встраивать еще один возможный сценарий. Думать над тем как с этим сценарием сочетаются другие сценарии, не возникает ли конфликтов и так далее.


<b>Плюсы и минусы</b>
+Больше не нужно следить за состоянием системы, что не может не радовать тех, кто пишет глубоко асинхронный код, состоящий преимущественно из одних только ajax-запросов. 
+Не нужны сверх-замороченные описания управляющего механизма приложения, что не может не радовать, тех, кто пишет сложные логические приложения (например анкету с очень хитрой спецификацией заполнения). Сам синтаксис велит писать очевидно.
+Легко поддерживать, дополнять, изменять приложение не опасаясь, что все накроется медным сосудом.

-Все равно, все чего мы пытаемся избежать прибегая к FRP в JavaScript так или иначе делается, но уже скрыто от нас в недрах Bacon.js.
-Производительность. Тщательное профилирование показало, что делая все в лоб выходит быстрее. Однако, проект развивается, и правильное его использование окупается
-Из моих субъективных ощущений, - это скорее эмуляция FRP. ClojureScript, например, предоставляет тот же функционал в более привычной форме. Я гораздо дольше вникал в прикладную разницу между свойствами и потоками соответствующими map'у, чем в работу тех же ячеек (cell) в Javelin. 

<b>Имеет ли все это смысл?</b>
Из всего написанного выше можно сделать вывод. Существует гипотетическая кривая зависимости нобходимости использования bacon.js от сложности приложения. Понятно, что для наведения красотулек на сайт или для одного только sign form никакого смысла нет использовать bacon.js. Библиотека конечно не тяжелая, но лучше сразу увидеть где можно ее применить, а где просто не нужно. Bacon.js разумно использовать там, где будет сложно ориентироваться без декларативного программирования. Даже если система большая и включает в себя огромное множество элементов, bacon использовать имеет смысл только тогда, когда эти элементы зависят друг от друга, изменение одних данных должно влечь за собой изменение других данных и так далее. Сложность в этом смысле не означает размер или совокупную сложность алгоритмов, скорее размер логической структуры приложения. 	


<b>Материалы</b>:
GitHub 
Slideshow - http://raimohanska.github.io/bacon.js-slides/
Желающим все-таки постичь дзен FRP: 







